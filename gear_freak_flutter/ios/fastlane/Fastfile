# Fastfile
# iOS 배포 자동화 스크립트

# 사용 통계 전송 비활성화 (선택사항)
opt_out_usage

# 기본 플랫폼
default_platform(:ios)

platform :ios do

  # ==================== App Store Connect API 인증 ====================

  before_all do
    # App Store Connect API 키 설정
    # 환경변수에서 읽어오거나 하드코딩된 값 사용
    api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"] || "Y28LL7R646"
    api_issuer_id = ENV["APP_STORE_CONNECT_ISSUER_ID"] || "fe34bf88-2267-4565-a7df-0208753cb935"

    # AuthKey.p8 파일 경로 (Fastfile과 같은 디렉토리, 절대 경로로 변환)
    key_filepath = File.expand_path("AuthKey.p8", __dir__)

    # 파일 존재 여부 확인
    unless File.exist?(key_filepath)
      UI.user_error!("❌ AuthKey.p8 파일을 찾을 수 없습니다: #{key_filepath}")
    end

    # 파일 크기 확인 (비어있는 파일 체크)
    if File.size(key_filepath) == 0
      UI.user_error!("❌ AuthKey.p8 파일이 비어있습니다")
    end

    # 파일 형식 검증 (PEM 형식 확인)
    file_content = File.read(key_filepath)
    unless file_content.start_with?("-----BEGIN PRIVATE KEY-----")
      UI.error("❌ AuthKey.p8 파일이 올바른 PEM 형식이 아닙니다")
      UI.error("파일 첫 줄: #{file_content.lines.first}")
      UI.user_error!("GitHub Secrets의 APP_STORE_CONNECT_API_KEY_CONTENT를 확인하세요")
    end

    UI.message("✅ AuthKey.p8 파일 검증 완료 (크기: #{File.size(key_filepath)} bytes)")

    app_store_connect_api_key(
      key_id: api_key_id,
      issuer_id: api_issuer_id,
      key_filepath: key_filepath,
      duration: 1200, # 20분 (선택사항)
      in_house: false # App Store 배포 (Enterprise가 아님)
    )
  end

  # ==================== TestFlight 베타 배포 ====================

  desc "TestFlight에 베타 버전 배포"
  desc "사용법: fastlane beta"
  lane :beta do
    # 1. 빌드 번호 자동 증가
    increment_build_number(
      xcodeproj: "Runner.xcodeproj"
    )

    # 2. iOS 앱 빌드
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.pyowonsik.gearFreakFlutter" => "match AppStore com.pyowonsik.gearFreakFlutter"  # 프로비저닝 프로파일 이름
        }
      }
    )

    # 3. TestFlight에 업로드
    upload_to_testflight(
      skip_waiting_for_build_processing: true  # 빌드 처리 대기 건너뛰기
    )

    # 4. 성공 메시지
    UI.success("✅ TestFlight 업로드 완료!")
    UI.success("App Store Connect에서 확인하세요: https://appstoreconnect.apple.com")
  end

  # ==================== App Store 정식 배포 ====================

  desc "App Store에 정식 버전 업로드 (심사 제출은 수동)"
  desc "사용법: fastlane release"
  lane :release do
    # 1. 빌드 번호 증가
    increment_build_number(xcodeproj: "Runner.xcodeproj")

    # 2. iOS 앱 빌드
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      export_options: {
        method: "app-store",
        provisioningProfiles: {
          "com.pyowonsik.gearFreakFlutter" => "match AppStore com.pyowonsik.gearFreakFlutter"  # 프로비저닝 프로파일 이름
        }
      }
    )

    # 3. App Store Connect에 업로드 (심사 제출 X)
    upload_to_app_store(
      submit_for_review: false,      # 자동 심사 제출 안 함
      automatic_release: false,      # 심사 통과 후 자동 배포 안 함
      skip_metadata: true,           # 메타데이터 업데이트 건너뛰기
      skip_screenshots: true         # 스크린샷 업데이트 건너뛰기
    )

    UI.success("✅ App Store Connect 업로드 완료!")
    UI.message("App Store Connect에서 수동으로 심사를 제출하세요")
  end

  # ==================== 빌드만 수행 ====================

  desc "iOS 앱 빌드만 수행 (업로드 없음)"
  desc "사용법: fastlane build_only"
  lane :build_only do
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      xcargs: "-allowProvisioningUpdates"  # 자동 프로비저닝 허용
    )

    UI.success("✅ 빌드 완료!")
    UI.message("빌드 파일 위치: #{lane_context[SharedValues::IPA_OUTPUT_PATH]}")
  end

  # ==================== 빌드 번호만 증가 ====================

  desc "빌드 번호만 1 증가"
  desc "사용법: fastlane bump_build"
  lane :bump_build do
    increment_build_number(xcodeproj: "Runner.xcodeproj")

    current_build = get_build_number(xcodeproj: "Runner.xcodeproj")
    UI.success("빌드 번호가 #{current_build}(으)로 업데이트되었습니다")
  end

end

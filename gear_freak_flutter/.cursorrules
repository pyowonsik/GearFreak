# Gear Freak 프로젝트 Cursor Rules

## Dialog 사용 규칙

- 프로젝트에서 사용하는 모든 다이얼로그는 `GbDialog`를 사용해야 합니다.
- `AlertDialog`를 직접 사용하지 말고, `GbDialog.show()`를 사용하세요.
- `GbDialog`는 `lib/common/component/gb_dialog.dart`에 위치합니다.

### 사용 예시

```dart
// ✅ 올바른 사용
final shouldDelete = await GbDialog.show(
  context: context,
  title: '상품 삭제',
  content: '정말로 이 상품을 삭제하시겠습니까?',
  confirmText: '삭제',
  cancelText: '취소',
  confirmColor: Colors.red,
);

// ❌ 잘못된 사용
showDialog(
  context: context,
  builder: (context) => AlertDialog(...),
);
```

## SnackBar 사용 규칙

- 프로젝트에서 사용하는 모든 스낵바는 `GbSnackBar`를 사용해야 합니다.
- `ScaffoldMessenger.of(context).showSnackBar()`와 `SnackBar`를 직접 사용하지 말고, `GbSnackBar`의 static 메서드를 사용하세요.
- `GbSnackBar`는 `lib/common/component/gb_snackbar.dart`에 위치합니다.

### 사용 예시

```dart
// ✅ 올바른 사용 - 성공 메시지
GbSnackBar.showSuccess(context, '상품이 등록되었습니다');

// ✅ 올바른 사용 - 에러 메시지
GbSnackBar.showError(context, '상품 삭제에 실패했습니다');

// ✅ 올바른 사용 - 경고 메시지
GbSnackBar.showWarning(context, '최소 1장의 이미지를 추가해주세요');

// ✅ 올바른 사용 - 정보 메시지
GbSnackBar.showInfo(context, '이미지는 최대 10장까지 추가할 수 있습니다');

// ✅ 올바른 사용 - 커스텀 타입 및 duration
GbSnackBar.show(
  context,
  '메시지',
  type: GbSnackBarType.success,
  duration: const Duration(seconds: 3),
);

// ❌ 잘못된 사용
ScaffoldMessenger.of(context).showSnackBar(
  SnackBar(
    content: Text('메시지'),
    backgroundColor: Colors.red,
  ),
);
```

### 스낵바 타입

- `GbSnackBar.showSuccess()`: 성공 메시지 (초록색, 체크 아이콘)
- `GbSnackBar.showError()`: 에러 메시지 (빨간색, 에러 아이콘, 기본 3초)
- `GbSnackBar.showWarning()`: 경고 메시지 (주황색, 경고 아이콘)
- `GbSnackBar.showInfo()`: 정보 메시지 (파란색, 정보 아이콘)

## ErrorView 사용 규칙

- 프로젝트에서 사용하는 모든 에러 상태 표시는 `GbErrorView`를 사용해야 합니다.
- 에러 아이콘, 메시지, "다시 시도" 버튼을 직접 구성하지 말고, `GbErrorView` 위젯을 사용하세요.
- `GbErrorView`는 `lib/common/component/gb_error_view.dart`에 위치합니다.

### 사용 예시

```dart
// ✅ 올바른 사용 - 기본 에러 뷰
GbErrorView(
  message: '상품을 불러올 수 없습니다',
  onRetry: () {
    ref.read(productNotifierProvider.notifier).loadProducts();
  },
)

// ✅ 올바른 사용 - 제목과 뒤로 가기 버튼 포함
GbErrorView(
  title: '오류가 발생했습니다',
  message: '상품을 불러오는 중 오류가 발생했습니다',
  onRetry: () {
    ref.read(productNotifierProvider.notifier).loadProduct(id);
  },
  showBackButton: true,
  onBack: () => context.pop(),
)

// ❌ 잘못된 사용
Center(
  child: Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: [
      Icon(Icons.error_outline, size: 64, color: Colors.red),
      Text('에러 메시지'),
      ElevatedButton(
        onPressed: () {},
        child: Text('다시 시도'),
      ),
    ],
  ),
)
```

### GbErrorView 파라미터

- `message` (필수): 에러 메시지
- `onRetry` (필수): 다시 시도 버튼 클릭 시 호출되는 콜백
- `title` (선택): 에러 제목
- `showBackButton` (선택, 기본값: false): 뒤로 가기 버튼 표시 여부
- `onBack` (선택): 뒤로 가기 버튼 클릭 시 호출되는 콜백 (showBackButton이 true일 때 필수)
- `icon` (선택, 기본값: Icons.error_outline): 에러 아이콘
- `iconSize` (선택, 기본값: 64): 아이콘 크기
- `iconColor` (선택, 기본값: Colors.red): 아이콘 색상

**참고**: 제목과 메시지 스타일은 프로젝트 전반에서 통일된 스타일을 사용합니다.
- 제목: `TextStyle(fontSize: 20, fontWeight: FontWeight.bold)`
- 메시지: `TextStyle(fontSize: 16, color: Colors.red)`

## EmptyView 사용 규칙

- 프로젝트에서 사용하는 모든 빈 상태 표시는 `GbEmptyView`를 사용해야 합니다.
- 빈 상태 아이콘, 메시지를 직접 구성하지 말고, `GbEmptyView` 위젯을 사용하세요.
- `GbEmptyView`는 `lib/common/component/gb_empty_view.dart`에 위치합니다.

### 사용 예시

```dart
// ✅ 올바른 사용 - 아이콘과 메시지
const GbEmptyView(
  icon: Icons.search,
  message: '상품을 검색해보세요',
)

// ✅ 올바른 사용 - 메시지만 (아이콘 없음)
const GbEmptyView(
  message: '등록된 상품이 없습니다',
)

// ✅ 올바른 사용 - 커스텀 아이콘 색상
const GbEmptyView(
  icon: Icons.search_off,
  message: '검색 결과가 없습니다',
  iconSize: 64,
  iconColor: Colors.grey,
)

// ❌ 잘못된 사용
Center(
  child: Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: [
      Icon(Icons.search, size: 64, color: Colors.grey.shade300),
      const SizedBox(height: 16),
      Text('상품을 검색해보세요'),
    ],
  ),
)
```

### GbEmptyView 파라미터

- `message` (필수): 빈 상태 메시지
- `icon` (선택): 빈 상태 아이콘 (없으면 아이콘 표시 안 함)
- `iconSize` (선택, 기본값: 64): 아이콘 크기
- `iconColor` (선택, 기본값: Colors.grey.shade300): 아이콘 색상

**참고**: 메시지 스타일은 프로젝트 전반에서 통일된 스타일을 사용합니다 (fontSize: 16, color: Color(0xFF9CA3AF)).

## LoadingView 사용 규칙

- 프로젝트에서 사용하는 모든 전체 화면 로딩 표시는 `GbLoadingView`를 사용해야 합니다.
- `Center(child: CircularProgressIndicator())`를 직접 사용하지 말고, `GbLoadingView` 위젯을 사용하세요.
- `GbLoadingView`는 `lib/common/component/gb_loading_view.dart`에 위치합니다.

### 사용 예시

```dart
// ✅ 올바른 사용 - 기본 로딩 뷰
const GbLoadingView()

// ✅ 올바른 사용 - 메시지가 있는 로딩 뷰
const GbLoadingView(
  message: '데이터를 불러오는 중...',
)

// ❌ 잘못된 사용
Center(child: CircularProgressIndicator())
```

### GbLoadingView 파라미터

- `message` (선택): 로딩 메시지 (없으면 CircularProgressIndicator만 표시)

## Clean Architecture 패턴

프로젝트는 **Clean Architecture**를 엄격하게 따릅니다. 모든 API 호출은 다음 레이어 구조를 따라야 합니다:

### 레이어 구조

```
Presentation (Provider/Notifier)
    ↓
Domain (UseCase)
    ↓
Domain (Repository Interface)
    ↑
Data (Repository Implementation)
    ↓
Data (DataSource)
```

### 1. Data Layer (데이터 소스)

**위치**: `lib/feature/{feature}/data/`

- **DataSource**: Serverpod Client를 사용한 API 호출만 담당
  - 파일: `datasource/{feature}_remote_datasource.dart`
  - Serverpod Client 직접 호출
  - Exception을 throw (Either 사용 안 함)

```dart
// ✅ 올바른 DataSource
class ProductRemoteDataSource {
  pod.Client get _client => PodService.instance.client;
  
  Future<pod.Product> getProductDetail(int id) async {
    try {
      return await _client.product.getProduct(id);
    } catch (e) {
      throw Exception('상품 상세를 불러오는데 실패했습니다: $e');
    }
  }
}

// ❌ 잘못된 사용 - UseCase나 Repository를 DataSource에서 직접 호출
```

- **Repository Implementation**: Domain의 Repository 인터페이스를 구현
  - 파일: `repository/{feature}_repository_impl.dart`
  - DataSource를 사용하여 데이터 가져오기
  - Domain의 Repository 인터페이스 구현

```dart
// ✅ 올바른 Repository Implementation
class ProductRepositoryImpl implements ProductRepository {
  final ProductRemoteDataSource remoteDataSource;
  
  @override
  Future<pod.Product> getProductDetail(int id) async {
    return remoteDataSource.getProductDetail(id);
  }
}
```

### 2. Domain Layer (비즈니스 로직)

**위치**: `lib/feature/{feature}/domain/`

- **Repository Interface**: 데이터 소스 추상화
  - 파일: `repository/{feature}_repository.dart`
  - 추상 클래스로 정의
  - 외부 의존성 없음 (순수 Dart)

```dart
// ✅ 올바른 Repository Interface
abstract class ProductRepository {
  Future<pod.Product> getProductDetail(int id);
  Future<void> deleteProduct(int productId);
}
```

- **UseCase**: 단일 책임 비즈니스 로직
  - 파일: `usecase/{action}_{feature}_usecase.dart`
  - Repository 인터페이스를 사용 (구현체가 아님)
  - `Either<Failure, T>` 패턴 사용
  - `UseCase<T, Params, Repo>` 인터페이스 구현

```dart
// ✅ 올바른 UseCase
class GetProductDetailUseCase
    implements UseCase<pod.Product, int, ProductRepository> {
  final ProductRepository repository;
  
  @override
  Future<Either<Failure, pod.Product>> call(int param) async {
    try {
      final result = await repository.getProductDetail(param);
      return Right(result);
    } on Exception catch (e) {
      return Left(GetProductDetailFailure('상품을 불러올 수 없습니다.', exception: e));
    }
  }
}

// ❌ 잘못된 사용 - DataSource를 직접 사용
class GetProductDetailUseCase {
  final ProductRemoteDataSource dataSource; // ❌
}
```

### 3. Presentation Layer (UI)

**위치**: `lib/feature/{feature}/presentation/`

- **Provider/Notifier**: Riverpod 상태 관리
  - 파일: `provider/{feature}_notifier.dart`
  - UseCase만 사용 (Repository나 DataSource 직접 사용 금지)
  - `StateNotifier` 또는 `Notifier` 사용

```dart
// ✅ 올바른 Notifier
class ProductDetailNotifier extends StateNotifier<ProductDetailState> {
  final GetProductDetailUseCase getProductDetailUseCase;
  
  Future<void> loadProductDetail(int productId) async {
    final result = await getProductDetailUseCase(productId);
    result.fold(
      (failure) => state = ProductDetailError(failure.message),
      (product) => state = ProductDetailLoaded(product),
    );
  }
}

// ❌ 잘못된 사용 - Repository나 DataSource 직접 사용
class ProductDetailNotifier {
  final ProductRepository repository; // ❌
  final ProductRemoteDataSource dataSource; // ❌
}
```

### 의존성 규칙

1. **Presentation → Domain**: Presentation은 Domain(UseCase)만 의존
2. **Data → Domain**: Data는 Domain(Repository Interface)를 구현
3. **Domain → 외부 없음**: Domain은 외부 의존성이 없어야 함
4. **직접 호출 금지**: 
   - ❌ Presentation에서 Repository나 DataSource 직접 사용 금지
   - ❌ UseCase에서 DataSource 직접 사용 금지
   - ❌ DataSource에서 다른 DataSource나 UseCase 사용 금지

### 파일 구조 예시

```
lib/feature/product/
├── data/
│   ├── datasource/
│   │   └── product_remote_datasource.dart  # Serverpod Client 호출
│   └── repository/
│       └── product_repository_impl.dart    # Repository 인터페이스 구현
├── domain/
│   ├── repository/
│   │   └── product_repository.dart         # Repository 인터페이스
│   └── usecase/
│       └── get_product_detail_usecase.dart # 비즈니스 로직
└── presentation/
    └── provider/
        └── product_detail_notifier.dart    # UseCase 사용
```

### Provider 설정

모든 의존성은 Riverpod Provider로 주입됩니다:

```dart
// ✅ 올바른 Provider 구조
final productRemoteDataSourceProvider = Provider<ProductRemoteDataSource>((ref) {
  return const ProductRemoteDataSource();
});

final productRepositoryProvider = Provider<ProductRepository>((ref) {
  final remoteDataSource = ref.watch(productRemoteDataSourceProvider);
  return ProductRepositoryImpl(remoteDataSource);
});

final getProductDetailUseCaseProvider = Provider<GetProductDetailUseCase>((ref) {
  final repository = ref.watch(productRepositoryProvider);
  return GetProductDetailUseCase(repository);
});

final productDetailNotifierProvider = StateNotifierProvider<ProductDetailNotifier, ProductDetailState>((ref) {
  final getProductDetailUseCase = ref.watch(getProductDetailUseCaseProvider);
  return ProductDetailNotifier(getProductDetailUseCase);
});
```

### 요약

- ✅ **DataSource**: Serverpod Client 직접 호출
- ✅ **Repository Implementation**: DataSource 사용, Domain 인터페이스 구현
- ✅ **Repository Interface**: Domain에 정의, 추상 클래스
- ✅ **UseCase**: Repository 인터페이스 사용, Either 패턴
- ✅ **Notifier**: UseCase만 사용, 상태 관리
- ❌ **레이어 건너뛰기 금지**: 각 레이어는 바로 아래 레이어만 의존
